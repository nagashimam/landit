# NestJSブリーフィングドキュメント

## 概要

NestJSは、効率的でスケーラブルなサーバーサイドアプリケーションを構築するためのフレームワークです。プログレッシブなJavaScriptを使用し、TypeScriptを完全にサポートしています。OOP（オブジェクト指向プログラミング）、FP（関数型プログラミング）、FRP（関数型リアクティブプログラミング）の要素を組み合わせ、堅牢なHTTPサーバーフレームワーク（Express/Fastify）の上に抽象化レイヤーを提供し、開発者が多様なサードパーティモジュールを利用できるようにします。Nestはモジュール化されたアーキテクチャで、再利用可能なロジックパーツの作成を可能にし、異なるタイプのアプリケーション（HTTPサーバー、マイクロサービス、WebSockets）にわたってコンポーネントを再利用できます。「Build once, use everywhere!」という哲学を持っています。

## 主要テーマと重要な事実

### 1\. コントローラー (Controllers)

- **目的**: コントローラーは、受信するリクエストを処理し、クライアントに応答を送信する役割を担います。ルーティングメカニズムにより、特定のリクエストを処理するコントローラーを決定します。
- **ルーティング**: @Controller() デコレータを使用して基本コントローラーを定義し、オプションのルートパスプレフィックスを指定できます。HTTPリクエストメソッド（@Get(), @Post(), @Put(), @Delete(), @Patch(), @Options(), @Head(), @All()）に対応するデコレータを使用して、特定のルートハンドラーを定義します。
- **応答**: デフォルトのステータスコードはGETリクエストで200、POSTリクエストで201です。@HttpCode() デコレータで変更可能です。@Res() デコレータを介してライブラリ固有の応答オブジェクトを注入することで、より細かい制御が可能です。
- **リクエストオブジェクト**: @Req(), @Res(), @Next(), @Session(), @Param(), @Body(), @Query(), @Headers(), @Ip(), @HostParam() などのデコレータを使用して、HTTPリクエストのさまざまなプロパティにアクセスできます。
- **非同期性**: Nestはasync関数をサポートしており、ルートハンドラーはPromiseを返すことで自動的に解決されます。RxJS Observablesもサポートしています。
- **DTO (Data Transfer Objects)**: リクエストペイロードのスキーマを定義するために使用され、@Body() デコレータとともに使用されます。

### 2\. プロバイダー (Providers)

- **コアコンセプト**: プロバイダーはNestのコアコンセプトであり、サービス、リポジトリ、ファクトリ、ヘルパーなど、依存関係として注入できる基本的なNestクラスです。これらはNestランタイムシステムによって管理されます。
- **サービス (Services)**: アプリケーションロジックを管理する理想的な候補です。@Injectable() デコレータを使用してクラスをプロバイダーとしてマークします。
- **依存性注入 (Dependency Injection - DI)**: Nestは強力なDIパターンを組み込んでいます。コンストラクターを通じてプロバイダーを注入し、Nestは依存関係を解決してインスタンスを返します。
- **スコープ (Scopes)**: プロバイダーにはライフタイム("スコープ")があり、アプリケーションのライフサイクルに沿います。
- **DEFAULT (Singleton)**: アプリケーション全体で共有される単一のインスタンス（デフォルト）。
- **REQUEST**: 着信する各リクエストごとに作成される新しいインスタンス。
- **TRANSIENT**: コンシューマーごとに新しい専用のインスタンスが提供されます。
- **ヒント**: 「ほとんどのユースケースではシングルトンスコープの使用が推奨されます。」
- **カスタムプロバイダー (Custom Providers)**: Nestは、定数値、既存のクラスの再利用、条件付きプロバイダー、動的にプロバイダーを作成するファクトリなどのカスタムプロバイダーを定義するさまざまな方法を提供します。
- useValue: 定数を注入する。
- useClass: 実行時の環境に応じて異なる実装を提供する。
- useFactory: 動的にプロバイダーを作成し、他のプロバイダーを注入することも可能。
- useExisting: エイリアスを作成し、既存のプロバイダーを再利用する。
- **非同期プロバイダー (Asynchronous Providers)**: アプリケーションの起動を遅延させて、非同期タスクが完了するのを待つ必要がある場合（例：データベース接続の確立）に使用されます。async/awaitとuseFactory構文を使用します。

### 3\. モジュール (Modules)

- **アプリケーションの構造化**: モジュールは@Module() デコレータで注釈されたクラスで、アプリケーション構造を効率的に整理および管理するためにNestによって使用されます。
- **ルートモジュール (Root Module)**: すべてのNestアプリケーションには、アプリケーショングラフを構築するための開始点となる少なくとも1つのルートモジュールがあります。
- **プロパティ**: @Module() デコレータは、以下のプロパティを持つオブジェクトを受け取ります。
- providers: Nestインジェクターによってインスタンス化され、このモジュール内で共有されるプロバイダーのリスト。
- controllers: このモジュール内でインスタンス化されるコントローラーのセット。
- imports: このモジュールが必要とする、エクスポートされたプロバイダーをインポートするモジュールのリスト。
- exports: 提供され、このモジュールをインポートする他のモジュールで利用可能になるプロバイダーのサブセット。
- **共有モジュール (Shared Modules)**: Nestでは、モジュールはデフォルトでシングルトンであるため、複数のモジュール間で同じプロバイダーインスタンスを簡単に共有できます。共有したいプロバイダーをモジュールのexports配列に追加する必要があります。
- **グローバルモジュール (Global Modules)**: global: trueプロパティを持つ@Global() デコレータを使用して、どこでも利用可能なプロバイダーのセットを提供できます。ただし、「すべてをグローバルにすることは良い設計上の決定ではありません。」と警告されています。
- **動的モジュール (Dynamic Modules)**: 実行時に設定できるモジュールを作成できます。これは、汎用設定モジュールやプラグインの概念に似ています。ConfigModule.register() のような静的メソッドを介して構成され、DynamicModuleインターフェースに適合するオブジェクトを返します。
- **遅延ロードモジュール (Lazy-Loading Modules)**: デフォルトでは、モジュールはアプリケーション起動時にすべてロードされます（Eagerly loaded）。遅延ロードは、特にサーバーレス環境でのブートストラップ時間の短縮に役立ちます。LazyModuleLoaderクラスを介してオンデマンドでモジュールをロードできます。「遅延ロードされたモジュールは、グローバルモジュールとして登録できません」また、「グローバルエンハンサー（ガード/インターセプターなど）は正しく機能しません。」

### 4\. 設定 (Configuration)

- **環境変数**: アプリケーションは異なる環境で実行されることが多く、設定が環境に依存する場合があります。NestJSは@nestjs/configパッケージを提供し、.envファイルからのキーと値のペアを保持します。
- **ConfigModule**: ConfigModule.forRoot() メソッドを使用して設定モジュールをインポートします。ConfigServiceプロバイダーを登録し、設定値の読み取りを可能にします。
- **カスタムenvファイルパス**: envFilePathプロパティを使用して、カスタム.envファイルのパスを指定できます。複数のファイルを指定でき、最初に見つかった変数が優先されます。
- **env変数ロードの無効化**: ignoreEnvFile: trueを設定することで、.envファイルのロードを無効にし、ランタイム環境変数のみにアクセスできます。
- **カスタム設定ファイル**: JavaScriptオブジェクトを返すファクトリ関数として設定ファイルを定義し、ConfigModule.forRoot({ load: \[configuration\] }) でロードできます。YAMLファイルもサポートしています。
- **ConfigService**: get() メソッドを使用して環境変数やカスタム設定値を取得します。型ヒントを付けて厳密に型指定された設定オブジェクトを操作できます。
- **名前空間付き設定 (Namespaced Configurations)**: registerAs() ファクトリ関数を使用すると、名前空間付き設定オブジェクトを定義でき、ConfigService.get('namespace.key') のようにドット記法でアクセスできます。
- **スキーマ検証 (Schema Validation)**: joiパッケージまたはカスタムvalidate関数を使用して、環境変数を検証し、アプリケーションの起動時に例外をスローできます。
- **環境変数ロードフック**: ConfigModule.envVariablesLoaded Promiseを利用して、.envファイルがロードされた後にコードが実行されることを保証できます。
- **展開可能な変数 (Expandable Variables)**: 環境変数内で他の環境変数を参照して展開をサポートします（例：APP_URL=mywebsite.com SUPPORT_EMAIL=${APP_URL}）。

### 5\. CLIプラグイン (CLI Plugins)

- **目的**: Nest CLIプラグインは、Swagger UI用のメタデータ反射システムを拡張し、TypeScriptコンパイルプロセスを軽減してボイラープレートコードの量を減らします。
- **Swaggerプラグイン**: @ApiProperty デコレータなしでDTOプロパティに注釈を付け、必要なプロパティを設定し、タイプやenumを設定し、デフォルト値を設定し、複数の検証ルールを追加し、各エンドポイントにレスポンスデコレータを追加し、プロパティの記述と例を生成します。
- **コメントのイントロスペクション**: introspectCommentsを有効にすると、CLIプラグインはコメントに基づいてプロパティの記述と例の値を生成できます。
- **使用方法**: nest-cli.jsonファイルにプラグインを追加して有効にします。オプションプロパティを介して動作をカスタマイズできます。

### 6\. デコレータ (Decorators)

- **言語機能**: デコレータは、JavaScriptの世界では比較的新しい言語機能であり、クラス、メソッド、またはプロパティをデコレートするために使用されます。
- **OpenAPIデコレータ**: Apiプレフィックスを持つデコレータが提供され、OpenAPI仕様を記述するために使用されます（例：@ApiBasicAuth(), @ApiProperty(), @ApiResponses()）。

### 7\. 循環依存性 (Circular Dependencies)

- **定義**: 循環依存性は、2つのクラスが互いに依存している場合に発生します。Nestはモジュールとプロバイダー間で循環依存性を解決できます。
- **フォワードリファレンス (Forward Reference)**: Nestがまだ定義されていないクラスを参照できるようにするテクニックです。forwardRef() ユーティリティ関数を使用します。
- **ModuleRefクラスの代替**: ModuleRefクラスを使用してDIコンテナからプロバイダーインスタンスを取得する代替手段もあります。
- **モジュール間のフォワードリファレンス**: モジュール間の循環依存性を解決するためにもforwardRef() を使用します。
- **警告**: 「インスタンス化の順序は不定です。コンストラクターが未定義の依存関係に依存しないようにコードを記述してください。」

### 8\. 例外フィルター (Exception Filters)

- **組み込み例外レイヤー**: Nestには、アプリケーションのすべての未処理の例外を処理する組み込みの例外レイヤーがあります。これは、適切なユーザーフレンドリーな応答を自動的に送信します。
- **標準例外のスロー**: NestはHttpExceptionクラスを提供し、HTTP REST/GraphQL APIベースのアプリケーションで標準HTTP応答オブジェクトをスローするために使用されます。
- **カスタム例外**: HttpExceptionを拡張するカスタム例外を作成できます。
- **例外フィルターの作成**: カスタム例外フィルターはExceptionFilterインターフェースを実装し、@Catch() デコレータで例外のタイプを指定します。これにより、レスポンスの正確な制御とロギングロジックの実装が可能です。
- **フィルターのバインディング**: @UseFilters() デコレータを使用して、メソッドレベル、コントローラーレベル、またはグローバルレベルでフィルターをバインドできます。グローバルフィルターは、app.useGlobalFilters() メソッドを使用するか、APP_FILTERトークンを使用して登録できます。

### 9\. 実行コンテキスト (Execution Context)

- **ユーティリティクラス**: Nestは、複数のアプリケーションコンテキスト（HTTPサーバー、マイクロサービス、WebSockets）にわたって機能するアプリケーションを簡単に作成できるユーティリティクラスを提供します。
- **ArgumentsHost**: ハンドラーに渡される引数を取得するためのクラスです。catch() メソッドを提供し、適切なコンテキスト（HTTP、RPC、WebSockets）を切り替えるのに役立ちます。
- **ExecutionContext**: ArgumentsHostを拡張し、現在の実行プロセスに関する追加の詳細（例：コントローラークラスのタイプ、現在のハンドラーへの参照、パイプライン内の次のハンドラーへの参照）を提供します。
- **反射とメタデータ**: Nestは、Reflector#createDecoratorまたは組み込みの@SetMetadata() デコレータを通じて、ルートハンドラーにカスタムメタデータをアタッチする機能を提供します。Reflectorヘルパークラスを使用すると、このメタデータにアクセスできます。

### 10\. ガード (Guards)

- **目的**: ガードは@Injectable() デコレータで注釈されたクラスで、CanActivateインターフェースを実装します。リクエストがルートハンドラーによって処理されるべきかどうかを決定し、認証と認可ロジックの実装に役立ちます。
- **実行順序**: ガードは、インターセプターやパイプより前に実行されます。
- **canActivate() メソッド**: この関数はブール値を返します（Promise<boolean>またはObservable<boolean>）。trueを返すとリクエストは処理され、falseを返すとNestはリクエストを拒否します。
- **カスタムメタデータ**: Reflectorクラスと@SetMetadata() デコレータを使用することで、ルートハンドラーにカスタムメタデータをアタッチし、ガード内でこのメタデータに基づいて認可ロジックを実行できます。
- **ガードのバインディング**: @UseGuards() デコレータを使用して、コントローラーレベル、メソッドレベル、またはグローバルレベルでガードをバインドできます。グローバルガードは、app.useGlobalGuards() メソッドを使用するか、APP_GUARDトークンを使用して登録できます。

### 11\. インターセプター (Interceptors)

- **AOP (Aspect-Oriented Programming)**: インターセプターはAOPに触発された有用な機能を提供します。
- メソッド実行前後のロジックのバインド
- 関数からの結果の変換
- 関数からスローされた例外の変換
- 基本的な動作の拡張
- 特定の条件（例：キャッシュ目的）に応じて関数を完全にオーバーライド
- **intercept() メソッド**: ExecutionContextとCallHandlerの2つの引数を受け取ります。CallHandlerはhandle() メソッドを実装し、ルートハンドラーを呼び出します。
- **レスポンストランスフォーメーション**: intercept() メソッドはRxJS Observableを返すため、map() などのRxJSオペレータを使用してレスポンスを変換できます。
- **例外マッピング (Exception Mapping)**: catchError() オペレータを使用して、スローされた例外をオーバーライドできます。
- **ストリームのオーバーライド (Stream Overriding)**: キャッシュなどの目的で、ハンドラーを呼び出すのを完全に防ぎ、代わりに新しいストリームを返すことができます。
- **インターセプターのバインディング**: @UseInterceptors() デコレータを使用して、コントローラーレベル、メソッドレベル、またはグローバルレベルでインターセプターをバインドできます。グローバルインターセプターは、app.useGlobalInterceptors() メソッドを使用するか、APP_INTERCEPTORトークンを使用して登録できます。

### 12\. ミドルウェア (Middleware)

- **実行順序**: ミドルウェアはルートハンドラーの前に実行され、リクエスト-レスポンスサイクルにアクセスできます。next() 関数は次のミドルウェア関数に制御を渡します。
- **機能**: 任意のコードを実行し、リクエストとレスポンスオブジェクトを変更し、リクエスト-レスポンスサイクルを終了できます。
- **カスタムミドルウェア**: @Injectable() デコレータを持つクラスとしてカスタムミドルウェアを実装するか、単純な関数として実装できます。クラスベースのミドルウェアはDIを完全にサポートしています。
- **ミドルウェアの適用**: configure() メソッド内でMiddlewareConsumerインターフェースを使用してミドルウェアを適用します。forRoutes() を使用して特定のルート、コントローラー、またはワイルドカードパスに適用できます。
- **ルートの除外**: exclude() メソッドを使用して、ミドルウェアが適用されない特定のルートを定義できます。
- **グローバルミドルウェア**: app.use() メソッドを使用して、すべての登録済みルートにミドルウェアをバインドできます。グローバルミドルウェアでDIコンテナにアクセスするには、関数型ミドルウェアを使用する必要があります。

### 13\. HTTPモジュール (HTTP Module)

- **目的**: Nestは、広く使用されているHTTPクライアントパッケージであるAxiosをラップしたHttpModuleを提供します。HttpServiceクラスは、HTTPリクエストを実行するためのAxiosベースのメソッドを公開し、結果のHTTPレスポンスをObservablesに変換します。
- **設定**: HttpModule.register() メソッドを使用して、Axiosインスタンスの動作を構成できます。
- **非同期設定**: registerAsync() メソッドを使用して、モジュールオプションを非同期に渡すことができます。ファクトリ関数や、createHttpOptions() メソッドを実装するクラスを使用できます。

### 14\. ライフサイクルイベント (Lifecycle Events)

- **ライフサイクル**: Nestアプリケーションは、初期化、実行、終了の3つのフェーズでライフサイクルを管理します。
- **ライフサイクルフック**: Nestは、モジュール、プロバイダー、コントローラーで発生するライフサイクルフックを提供します。
- onModuleInit(): ホストモジュールの依存関係が解決された後、一度呼び出されます。
- onApplicationBootstrap(): すべてのモジュールが初期化され、接続をリッスンする前に呼び出されます。
- onModuleDestroy(): 終了シグナル（例：SIGTERM）を受け取ったときに呼び出されます。
- beforeApplicationShutdown(): onModuleDestroy() ハンドラーがすべて呼び出された後に呼び出されます。
- onApplicationShutdown(): 接続クローズ後に呼び出されます。
- **非同期初期化**: onModuleInitおよびonApplicationBootstrapフックはPromiseを返すことができ、アプリケーションの初期化プロセスを遅延させることができます。
- **アプリケーションシャットダウンフック**: enableShutdownHooks() を呼び出すことで、システムリソースを消費するシャットダウンフックをリッスンできます。

### 15\. モジュールリファレンス (Module Reference)

- **ModuleRef**: NestはModuleRefクラスを提供し、プロバイダーの内部リストをナビゲートし、ルックアップキーを使用して任意のプロバイダーへの参照を取得できます。動的にインスタンス化されていない静的プロバイダーおよびスコープ付きプロバイダーを動的にインスタンス化する方法も提供します。
- **インスタンスの取得**: get() メソッドは、現在のモジュールで登録およびインスタンス化されたプロバイダー、コントローラー、またはインジェクタブルのインスタンスを返します。
- **スコープ付きプロバイダーの解決**: resolve() メソッドは、トランジェントまたはリクエストスコープのプロバイダーのユニークなインスタンスを返します。ContextIdFactory.create() を使用してコンテキスト識別子を生成できます。
- **カスタムクラスの動的インスタンス化**: ModuleRefのcreate() メソッドを使用して、以前にプロバイダーとして登録されていないクラスを動的にインスタンス化できます。

### 16\. テスト (Testing)

- **自動テスト**: Nestは、単体テスト、エンドツーエンド（e2e）テスト、統合テストなど、さまざまなタイプのテストをサポートしています。
- **テストユーティリティ**: @nestjs/testingパッケージは、堅牢なテストプロセスを可能にするユーティリティセットを提供します。
- **Testクラス**: Nestアプリケーションの実行コンテキストを基本的にモックするのに役立ちます。createTestingModule() メソッドはTestingModuleを返し、モジュールをコンパイルします。
- **モック**: useMocker() メソッドを使用して、不足している依存関係すべてにモックファクトリを定義できます。jest-mockと組み合わせて使用できます。
- **エンドツーエンドテスト**: supertestなどのライブラリと組み合わせて、HTTPリクエストをシミュレートし、APIエンドポイントの動作をテストします。
- **グローバルエンハンサーのオーバーライド**: グローバルに登録されたガード、パイプ、インターセプター、またはフィルターをオーバーライドできます。useExistingを使用するか、TestingModuleでoverrideProviderを使用します。

### 17\. OpenAPI (Swagger)

- **仕様の生成**: Nestは、デコレータを活用してOpenAPI（Swagger）仕様を生成するための専用モジュールを提供します。
- **SwaggerModule**: main.tsファイルでSwaggerModule.createDocument() を使用してSwaggerドキュメントを初期化し、SwaggerModule.setup() でSwagger UIを公開します。
- **DocumentBuilder**: OpenAPI仕様のベースドキュメントを構築するためのクラスです。タイトル、説明、バージョン、タグなどを設定できます。
- **デコレータ**: Apiプレフィックスを持つデコレータ（@ApiTags(), @ApiHeader(), @ApiResponse(), @ApiProperty(), @ApiExtension(), @ApiExtraModels(), @ApiSecurity() など）を使用して、APIの動作、応答、スキーマ、セキュリティなどを記述します。
- **CLIプラグインとの統合**: Swaggerプラグインは、クラスバリエーションデコレータに基づいて@ApiProperty() 注釈を自動的に生成し、ボイラープレートを減らします。
- **mapped typesとの互換性**: PartialType, PickType, OmitType, IntersectionTypeなどのユーティリティ関数を使用して、DTOのバリエーションを作成し、Swaggerドキュメントに反映できます。
- **セキュリティ**: @ApiSecurity() デコレータを使用して、特定の操作で使用すべきセキュリティメカニズムを定義できます。Basic、Bearer、OAuth2、Cookie認証がサポートされています。
- **その他の機能**: グローバルプレフィックスの無視、グローバルパラメータ、グローバルレスポンスの定義、複数のSwagger仕様のサポートなどがあります。

### 18\. バージョニング (Versioning)

- **目的**: アプリケーションのコントローラーや個々のルートの異なるバージョンをサポートし、互換性のない変更があっても古いバージョンをサポートできるようにします。
- **サポートされるタイプ**:
- **URI Versioning**: リクエストのURI内でバージョンを渡します（デフォルト）。
- **Header Versioning**: カスタムリクエストヘッダーがバージョンを指定します。
- **Media Type Versioning**: Acceptヘッダーにキーと値のペアを渡してバージョンを指定します。
- **Custom Versioning**: 抽出関数を介してバージョンを抽出します。
- **使用方法**: app.enableVersioning() メソッドを使用してバージョン管理を有効にし、タイプとオプションを指定します。
- **コントローラーとルートのバージョン**: @Controller({ version: '1' }) や @Version('1') デコレータを使用して、コントローラー全体または個々のルートにバージョンを適用できます。複数のバージョンを配列で指定することも可能です。
- **バージョン「ニュートラル」**: VERSION_NEUTRALシンボルを使用すると、コントローラーやルートがバージョンを気にせず、バージョンに関係なく同じ機能を持つようにできます。

このブリーフィングドキュメントは、提供されたNestJSドキュメントの主要な概念と最も重要な側面をカバーしています。
